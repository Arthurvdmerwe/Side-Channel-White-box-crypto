#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

const uint8_t S_box[]     = {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};
const uint8_t gmul[3][0x100]    = {
                                {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF},
                                {0x00 ,0x02 ,0x04 ,0x06 ,0x08 ,0x0A ,0x0C ,0x0E ,0x10 ,0x12 ,0x14 ,0x16 ,0x18 ,0x1A ,0x1C ,0x1E ,0x20 ,0x22 ,0x24 ,0x26 ,0x28 ,0x2A ,0x2C ,0x2E ,0x30 ,0x32 ,0x34 ,0x36 ,0x38 ,0x3A ,0x3C ,0x3E ,0x40 ,0x42 ,0x44 ,0x46 ,0x48 ,0x4A ,0x4C ,0x4E ,0x50 ,0x52 ,0x54 ,0x56 ,0x58 ,0x5A ,0x5C ,0x5E ,0x60 ,0x62 ,0x64 ,0x66 ,0x68 ,0x6A ,0x6C ,0x6E ,0x70 ,0x72 ,0x74 ,0x76 ,0x78 ,0x7A ,0x7C ,0x7E ,0x80 ,0x82 ,0x84 ,0x86 ,0x88 ,0x8A ,0x8C ,0x8E ,0x90 ,0x92 ,0x94 ,0x96 ,0x98 ,0x9A ,0x9C ,0x9E ,0xA0 ,0xA2 ,0xA4 ,0xA6 ,0xA8 ,0xAA ,0xAC ,0xAE ,0xB0 ,0xB2 ,0xB4 ,0xB6 ,0xB8 ,0xBA ,0xBC ,0xBE ,0xC0 ,0xC2 ,0xC4 ,0xC6 ,0xC8 ,0xCA ,0xCC ,0xCE ,0xD0 ,0xD2 ,0xD4 ,0xD6 ,0xD8 ,0xDA ,0xDC ,0xDE ,0xE0 ,0xE2 ,0xE4 ,0xE6 ,0xE8 ,0xEA ,0xEC ,0xEE ,0xF0 ,0xF2 ,0xF4 ,0xF6 ,0xF8 ,0xFA ,0xFC ,0xFE ,0x1B ,0x19 ,0x1F ,0x1D ,0x13 ,0x11 ,0x17 ,0x15 ,0x0B ,0x09 ,0x0F ,0x0D ,0x03 ,0x01 ,0x07 ,0x05 ,0x3B ,0x39 ,0x3F ,0x3D ,0x33 ,0x31 ,0x37 ,0x35 ,0x2B ,0x29 ,0x2F ,0x2D ,0x23 ,0x21 ,0x27 ,0x25 ,0x5B ,0x59 ,0x5F ,0x5D ,0x53 ,0x51 ,0x57 ,0x55 ,0x4B ,0x49 ,0x4F ,0x4D ,0x43 ,0x41 ,0x47 ,0x45 ,0x7B ,0x79 ,0x7F ,0x7D ,0x73 ,0x71 ,0x77 ,0x75 ,0x6B ,0x69 ,0x6F ,0x6D ,0x63 ,0x61 ,0x67 ,0x65 ,0x9B ,0x99 ,0x9F ,0x9D ,0x93 ,0x91 ,0x97 ,0x95 ,0x8B ,0x89 ,0x8F ,0x8D ,0x83 ,0x81 ,0x87 ,0x85 ,0xBB ,0xB9 ,0xBF ,0xBD ,0xB3 ,0xB1 ,0xB7 ,0xB5 ,0xAB ,0xA9 ,0xAF ,0xAD ,0xA3 ,0xA1 ,0xA7 ,0xA5 ,0xDB ,0xD9 ,0xDF ,0xDD ,0xD3 ,0xD1 ,0xD7 ,0xD5 ,0xCB ,0xC9 ,0xCF ,0xCD ,0xC3 ,0xC1 ,0xC7 ,0xC5 ,0xFB ,0xF9 ,0xFF ,0xFD ,0xF3 ,0xF1 ,0xF7 ,0xF5 ,0xEB ,0xE9 ,0xEF ,0xED ,0xE3 ,0xE1 ,0xE7 ,0xE5},
                                {0x00 ,0x03 ,0x06 ,0x05 ,0x0C ,0x0F ,0x0A ,0x09 ,0x18 ,0x1B ,0x1E ,0x1D ,0x14 ,0x17 ,0x12 ,0x11 ,0x30 ,0x33 ,0x36 ,0x35 ,0x3C ,0x3F ,0x3A ,0x39 ,0x28 ,0x2B ,0x2E ,0x2D ,0x24 ,0x27 ,0x22 ,0x21 ,0x60 ,0x63 ,0x66 ,0x65 ,0x6C ,0x6F ,0x6A ,0x69 ,0x78 ,0x7B ,0x7E ,0x7D ,0x74 ,0x77 ,0x72 ,0x71 ,0x50 ,0x53 ,0x56 ,0x55 ,0x5C ,0x5F ,0x5A ,0x59 ,0x48 ,0x4B ,0x4E ,0x4D ,0x44 ,0x47 ,0x42 ,0x41 ,0xC0 ,0xC3 ,0xC6 ,0xC5 ,0xCC ,0xCF ,0xCA ,0xC9 ,0xD8 ,0xDB ,0xDE ,0xDD ,0xD4 ,0xD7 ,0xD2 ,0xD1 ,0xF0 ,0xF3 ,0xF6 ,0xF5 ,0xFC ,0xFF ,0xFA ,0xF9 ,0xE8 ,0xEB ,0xEE ,0xED ,0xE4 ,0xE7 ,0xE2 ,0xE1 ,0xA0 ,0xA3 ,0xA6 ,0xA5 ,0xAC ,0xAF ,0xAA ,0xA9 ,0xB8 ,0xBB ,0xBE ,0xBD ,0xB4 ,0xB7 ,0xB2 ,0xB1 ,0x90 ,0x93 ,0x96 ,0x95 ,0x9C ,0x9F ,0x9A ,0x99 ,0x88 ,0x8B ,0x8E ,0x8D ,0x84 ,0x87 ,0x82 ,0x81 ,0x9B ,0x98 ,0x9D ,0x9E ,0x97 ,0x94 ,0x91 ,0x92 ,0x83 ,0x80 ,0x85 ,0x86 ,0x8F ,0x8C ,0x89 ,0x8A ,0xAB ,0xA8 ,0xAD ,0xAE ,0xA7 ,0xA4 ,0xA1 ,0xA2 ,0xB3 ,0xB0 ,0xB5 ,0xB6 ,0xBF ,0xBC ,0xB9 ,0xBA ,0xFB ,0xF8 ,0xFD ,0xFE ,0xF7 ,0xF4 ,0xF1 ,0xF2 ,0xE3 ,0xE0 ,0xE5 ,0xE6 ,0xEF ,0xEC ,0xE9 ,0xEA ,0xCB ,0xC8 ,0xCD ,0xCE ,0xC7 ,0xC4 ,0xC1 ,0xC2 ,0xD3 ,0xD0 ,0xD5 ,0xD6 ,0xDF ,0xDC ,0xD9 ,0xDA ,0x5B ,0x58 ,0x5D ,0x5E ,0x57 ,0x54 ,0x51 ,0x52 ,0x43 ,0x40 ,0x45 ,0x46 ,0x4F ,0x4C ,0x49 ,0x4A ,0x6B ,0x68 ,0x6D ,0x6E ,0x67 ,0x64 ,0x61 ,0x62 ,0x73 ,0x70 ,0x75 ,0x76 ,0x7F ,0x7C ,0x79 ,0x7A ,0x3B ,0x38 ,0x3D ,0x3E ,0x37 ,0x34 ,0x31 ,0x32 ,0x23 ,0x20 ,0x25 ,0x26 ,0x2F ,0x2C ,0x29 ,0x2A ,0x0B ,0x08 ,0x0D ,0x0E ,0x07 ,0x04 ,0x01 ,0x02 ,0x13 ,0x10 ,0x15 ,0x16 ,0x1F ,0x1C ,0x19 ,0x1A}
                            };
const uint8_t rcon[]      = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D};
const uint8_t MDS[4] = {2,3,1,1};

#define rotate(a) (((a) >> 8) | ((a) << 24))
#define dword(t)  (((t)[0]) | (((t)[1]) << 8) | (((t)[2]) << 16) | (((t)[3]) << 24))

typedef struct sub_s {
    uint8_t sub[0x100];
    uint8_t inv_sub[0x100];
} *sub_t;

typedef struct aes_wb_s {
    struct sub_s initSub;
    struct sub_s finalSub;
    uint8_t xorTables[3][0x10000];
    uint8_t roundTables[9][16][4][0x100];
    uint8_t finalTable[16][0x100];
} *aes_wb_t;

#include <windows.h>
DWORD sec_rnd()
{
    HCRYPTPROV hProvider = 0;
    DWORD retval;

    if (! CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
        return GetTickCount();

    if (! CryptGenRandom(hProvider, 4, (BYTE*)&retval))
    {
        CryptReleaseContext(hProvider, 0);
        return GetTickCount();
    }

    if (! CryptReleaseContext(hProvider, 0));

    return retval;
}

void key_schedule(aes_wb_t aes, const uint8_t key[16], uint8_t (*xkey)[11][16])
{
    uint8_t i;
    uint32_t d;

    memcpy((*xkey)[0], key, 16);
    d = dword(&(*xkey)[0][12]);
    for (i = 1; i < 11; i ++)
    {
        uint8_t j;

        d = rotate(d);
        for (j = 0; j < 32; j += 8)
            d = (S_box[(d >> j) & 0xFF] << j) | (d & ~(0xFF << j));
        d ^= rcon[i];

        for (j = 0; j < 16; j += 4)
        {
            d ^= dword(&(*xkey)[i-1][j]);
            (*xkey)[i][j] = d;
            (*xkey)[i][j+1] = d >> 8;
            (*xkey)[i][j+2] = d >> 16;
            (*xkey)[i][j+3] = d >> 24;
        }
    }
    /*
    // uncomment to check key schedule
    for (d = 0; d < 11u*16u; d++)
    {
        if (d % 16 == 0)
            printf("\n");
        printf("%02X ", (*xkey)[d/16u][d%16u]);
    }
    */

}

void new_sub(sub_t sub)
{
    uint16_t i;
    uint8_t r;
    const uint8_t masks[] = {0, 1, 3, 3, 7, 7, 7, 7, 15, 15, 15, 15, 15, 15, 15, 15, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
    for (i = 0; i < 0x100; i++)
        sub->sub[i] = (uint8_t)i;

    for (i = 0xFF; i > 0; i--)
    {
        uint8_t tmp;
        while((r = (sec_rnd() & masks[i])) > i);
        tmp = sub->sub[i];
        sub->sub[i] = sub->sub[r];
        sub->sub[r] = tmp;
    }

    for (i = 0; i < 0x100; i++)
        sub->inv_sub[sub->sub[i]] = (uint8_t)i;
}

void new_aes(aes_wb_t aes, const uint8_t key[16])
{
    uint8_t i;
    uint8_t round;
    uint32_t w;
    struct sub_s byteSubs[4];
    struct sub_s xorSubs[3];
    uint8_t xkey[11][16];

    key_schedule(aes, key, &xkey);

    new_sub(&aes->initSub);
    new_sub(&aes->finalSub);
    for  (i = 0; i < 4; i++)
        new_sub(&byteSubs[i]);
    for  (i = 0; i < 3; i++)
        new_sub(&xorSubs[i]);

    for (w = 0; w < 0x10000u; w++)
    {
        uint8_t b0 = w >> 8;
        uint8_t b1 = w & 0xFF;
        b0 = byteSubs[0].inv_sub[b0];
        b1 = byteSubs[1].inv_sub[b1];
        aes->xorTables[0][w] = xorSubs[0].sub[b0 ^ b1];
    }

    for (w = 0; w < 0x10000u; w++)
    {
        uint8_t b2 = w >> 8;
        uint8_t b3 = w & 0xFF;
        b2 = byteSubs[2].inv_sub[b2];
        b3 = byteSubs[3].inv_sub[b3];
        aes->xorTables[1][w] = xorSubs[1].sub[b2 ^ b3];
    }

    for (w = 0; w < 0x10000u; w++)
    {
        uint8_t b01 = w >> 8;
        uint8_t b23 = w & 0xFF;
        b01 = xorSubs[0].inv_sub[b01];
        b23 = xorSubs[1].inv_sub[b23];
        aes->xorTables[2][w] = xorSubs[2].sub[b01 ^ b23];
    }

    // round 0
    for (i = 0; i < 16; i++)
    {
        uint8_t  j;
        uint16_t b;
        uint8_t  rands[4];

        for (j = 1; j < 4; j++)
            rands[j] = (uint8_t)sec_rnd();
        rands[0] = rands[1]^rands[2]^rands[3]^xkey[1][(i%4u)*4 + i/4u];

        for (j = 0; j < 4; j++)
        {
            uint8_t k1 = xkey[0][j + ((i+j) % 4u)*4];
            const uint8_t* mul = gmul[MDS[((i/4u)*3 + j) % 4u]-1];
            uint8_t k2 = rands[j];
            uint8_t *bsub = byteSubs[j].sub;

            for (b = 0; b < 0x100; b++)
            {
                uint8_t n = aes->initSub.sub[b];
                n ^= k1;
                n = S_box[n];
                n = mul[n];
                n ^= k2;
                aes->roundTables[0][i][j][b] = bsub[n];
            }
        }
    }

    for (round = 1; round < 9; round ++)
    {
        for (i = 0; i < 16; i++)
        {
            uint8_t  j;
            uint16_t b;
            uint8_t  rands[4];

            for (j = 1; j < 4; j++)
                rands[j] = (uint8_t)sec_rnd();
            rands[0] = rands[1]^rands[2]^rands[3]^xkey[round+1][(i%4u)*4 + i/4u];

            for (j = 0; j < 4; j++)
            {
                const uint8_t* mul = gmul[MDS[((i/4u)*3 + j) % 4u]-1];
                uint8_t k = rands[j];
                uint8_t *bsub = byteSubs[j].sub;

                for (b = 0; b < 0x100; b++)
                {
                    uint8_t n = xorSubs[2].inv_sub[b];
                    n = S_box[n];
                    n = mul[n];
                    n ^= k;
                    aes->roundTables[round][i][j][b] = bsub[n];
                }
            }
        }
    }

    // round 10
    for ( i = 0; i < 16; i++)
    {
         uint16_t b;
         uint8_t k = xkey[10][(i%4u)*4 + i/4u];

         for (b = 0; b < 0x100; b++)
         {
             uint8_t n = xorSubs[2].inv_sub[b];
             n = S_box[n];
             n ^= k;
             aes->finalTable[i][b] = aes->finalSub.sub[n];
         }
    }
}

int main()
{
    struct aes_wb_s aes;
    uint8_t i, round;
    uint8_t t[12][16];
    uint8_t m[] = "testtesttesttest";
    FILE* f;
    new_aes(&aes, "KEY_KEY_KEY_KEY_");

    for (i = 0; i < 16; i++)
        t[0][(i%4u)*4 + (i/4u)] = aes.initSub.inv_sub[m[i]];

    // black magic...
    for (round = 1; round < 10; round ++)
    {
        for (i = 0; i < 16; i++)
        {
            uint8_t b[4];
            uint8_t j;
            for (j = 0; j < 4; j++)
                b[j] = aes.roundTables[round-1][i][j][t[round-1][j*4+((i+j)%4u)]];
            t[round][i] = aes.xorTables[2][(aes.xorTables[0][(b[0]<<8)|b[1]] << 8) | aes.xorTables[1][(b[2]<<8)|b[3]]];
        }
    }
    for (i = 0; i < 16; i++)
        t[10][i/4u + (i%4u)*4] = aes.finalTable[i][t[9][(i&(~3)) +((i+i/4)%4u)]];

    /*
    >>> from Crypto.Cipher import AES
    >>> " ".join("%02X"%ord(c) for c in AES.new("KEY_KEY_KEY_KEY_").encrypt("testtesttesttest"))
    '4C 74 7B 5C 53 54 DB 2B 6D 13 39 C9 31 81 33 40'
    */
    printf("pre-calc: 4C 74 7B 5C 53 54 DB 2B 6D 13 39 C9 31 81 33 40\ncomputed: ");

    // check...
    for (i = 0; i < 16; i++)
        printf("%02X ", aes.finalSub.inv_sub[t[10][i]]);
    printf("\n");



    f = fopen("wbt", "wb");
    fwrite(&aes, 1, sizeof(aes), f);
    fclose(f);
    return 0;
}